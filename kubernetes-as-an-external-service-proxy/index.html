<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="utf-8" />
    <meta name="author" content="Elijah Voigt">
    <link rel="stylesheet" type="text/css" href="../theme/css/styles.css"/>
        <link href="/rss.xml" type="application/rss+xml"   rel="alternate" title="elijahcaine.me RSS Feed" />
        <link href="/atom.xml" type="application/atom+xml" rel="alternate" title="elijahcaine.me Atom Feed" />
  </head>

  <body>
    <div class="site">
      <header>
        <a href="/">(🏠 elijahcaine.me)</a>
        <a href="https://github.com/pop/">(🐙 github 🐱)</a>
        <a href="/Elijah Voigt.pdf">(👔 resume)</a>
        <a href="/atom.xml">(📰 feed)</a>
      </header>

      <div id="content">

<div class="post">
  <h1 class="posttitle">
    Kubernetes as an external service proxy
  </h1>

  <div class="postinfo">
    <p class="published" title="2018-10-13T00:00:00-07:00">
      Sat 13 October 2018
    </p>
  </div>
</div>

<div class="article">
  <p>Say you have a firewall restriction that creates the following situation:</p>
<ol class="arabic simple">
<li>App1 cannot communicate directly with App2.</li>
<li>App1 and App2 can both talk to a Kubernets cluster.</li>
<li>Neither app is hosted on the Kubernetes cluster.</li>
<li>How can you get messages between App1 and App2?</li>
</ol>
<p>The way the problem is stated makes it pretty obvious that the solution <em>involves</em> using a Kubernetes cluster, but how exactly?</p>
<p>The naive solution might be to spin up a container which acts as a proxy; Nginx comes to mind.
This would definitely work, but I am exceedingly lazy and don't want to learn how to configure Nginx.
In fact, the solution I came to doesn't involve running any new pods!</p>
<p>Here's the code.
Below I'll explain what's happening here and why it works.</p>
<pre class="code yaml literal-block">
<span class="nt">kind</span><span class="p">:</span> <span class="l-Scalar-Plain">Endpoints</span>
<span class="nt">metadata</span><span class="p">:</span>
  <span class="nt">name</span><span class="p">:</span> <span class="l-Scalar-Plain">myapp-proxy</span>
<span class="nt">subsets</span><span class="p">:</span>
<span class="p-Indicator">-</span> <span class="nt">addresses</span><span class="p">:</span>
  <span class="p-Indicator">-</span> <span class="nt">ip</span><span class="p">:</span> <span class="l-Scalar-Plain">2.3.4.5k</span> <span class="c1"># App2's address</span>
  <span class="nt">ports</span><span class="p">:</span>
  <span class="p-Indicator">-</span> <span class="nt">port</span><span class="p">:</span> <span class="l-Scalar-Plain">8080</span> <span class="c1"># App2's service port</span>
<span class="nt">apiVersion</span><span class="p">:</span> <span class="l-Scalar-Plain">v1</span>

<span class="nn">---</span>

<span class="nt">kind</span><span class="p">:</span> <span class="l-Scalar-Plain">Service</span>
<span class="nt">metadata</span><span class="p">:</span>
  <span class="nt">name</span><span class="p">:</span> <span class="l-Scalar-Plain">myapp-proxy</span>
<span class="nt">spec</span><span class="p">:</span>
  <span class="nt">type</span><span class="p">:</span> <span class="l-Scalar-Plain">LoadBalancer</span>
  <span class="nt">loadBalancerSourceRanges</span><span class="p">:</span>
  <span class="p-Indicator">-</span> <span class="s">&quot;1.2.3.4/32&quot;</span> <span class="c1"># App1's address</span>
  <span class="nt">ports</span><span class="p">:</span>
  <span class="p-Indicator">-</span> <span class="nt">protocol</span><span class="p">:</span> <span class="l-Scalar-Plain">TCP</span>
    <span class="nt">port</span><span class="p">:</span> <span class="l-Scalar-Plain">80</span> <span class="c1"># Redirect traffic hitting 80 to the app's service port</span>
    <span class="nt">targetPort</span><span class="p">:</span> <span class="l-Scalar-Plain">8080</span>
<span class="nt">apiVersion</span><span class="p">:</span> <span class="l-Scalar-Plain">v1</span>

<span class="nn">---</span>

<span class="nt">kind</span><span class="p">:</span> <span class="l-Scalar-Plain">Ingress</span>
<span class="nt">metadata</span><span class="p">:</span>
<span class="nt">name</span><span class="p">:</span> <span class="l-Scalar-Plain">restaurant-proxy</span>
<span class="nt">spec</span><span class="p">:</span>
<span class="nt">rules</span><span class="p">:</span>
  <span class="p-Indicator">-</span> <span class="nt">host</span><span class="p">:</span> <span class="l-Scalar-Plain">myapp-proxy.somehost.net</span>
  <span class="nt">http</span><span class="p">:</span>
    <span class="nt">paths</span><span class="p">:</span>
    <span class="p-Indicator">-</span> <span class="nt">path</span><span class="p">:</span> <span class="l-Scalar-Plain">/</span>
        <span class="l-Scalar-Plain">backend</span><span class="p-Indicator">:</span>
          <span class="nt">serviceName</span><span class="p">:</span> <span class="l-Scalar-Plain">myapp-proxy</span>
          <span class="nt">servicePort</span><span class="p">:</span> <span class="l-Scalar-Plain">80</span>
<span class="nt">apiVersion</span><span class="p">:</span> <span class="l-Scalar-Plain">extensions/v1beta1</span>
</pre>
<div class="section" id="endpoints">
<h2>Endpoints</h2>
<p>Endpoints are the Kubernetes abstraction for IPs+Ports running the same application.
It's how you group together N instances of an app into one pool.</p>
<p>Under the hood Endpoints get created as a pre-requisite for every Service you deploy.
You don't usually need to deal with these directly as they are created implicitly whenever a Deployment gets applied.</p>
<p>By manually creating an endpoint we have imported our non-kubernetes app into Kubernetes.
That means we can do Kubernetes things with it like expose it via a Service or even put it behind an Ingress
Pretty neat!</p>
</div>
<div class="section" id="service">
<h2>Service</h2>
<p>Services are how we expose an endpoint to the world.
Most cloud providers will give you a public IP address for a service and load balance across all of that service's endpoints.</p>
<p>This is as far as we need to proxy traffic between our two Apps.
App1 makes a request to whatever IP Kubernetes gets for the <cite>myapp-proxy</cite> Service and relays it to the <cite>myapp-proxy</cite> endpoint, which ultimately routes the traffic to App2.
What's really cool is that the endpoint that <strong>is</strong> App2 can be an self-hosted Virtual Machine, as long as the IP doesn't change this proxy will continue to work.</p>
</div>
<div class="section" id="ingress">
<h2>Ingress</h2>
<p>Ingresses are my favorite part of Kubernetes.
They're very convenient, incredibly powerful, and they work like... over half the time.</p>
<p>While not strictly necessary, this Ingress gives us some nice-to-haves.</p>
<ul class="simple">
<li>Gives us an easy to manage host name via something like <a class="reference external" href="https://github.com/kubernetes-incubator/external-dns">External DNS</a>.</li>
<li>Could be extended to terminate SSL, again &quot;for free&quot;, with something like <a class="reference external" href="https://github.com/jetstack/cert-manager">Cert Manager</a>.</li>
</ul>
<p>So that's how we use Kubernetes to manage services (lower-case 's') which aren't running in Pods.</p>
</div>

</div>


      </div>

      <footer>
        <p>
        © 2024 Elijah Voigt, <a rel="license" href="http://creativecommons.org/licenses/by/4.0/"><img alt="Creative Commons License" style="border-width:0" src="/assets/images/CCA4IL.png" /> Creative Commons Attribution 4.0 International</a>.
        </p>
        <p>
        This website made with locally sourced bits, built with Python 🐍 via Pelican 🐦, developed on Fedora 👒 GNU/Linux 🐃🐧, <a href='https://github.com/pop/elijahcaine.me'>hosted</a> and deployed on GitHub 🐙🐱, and served from clouds ⛅.
        </p>
      </footer>
    </div>
  </body>
</html>